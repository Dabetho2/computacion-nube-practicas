from flask import Blueprint, request, jsonify, session
from decimal import Decimal
from db.db import db
from orders.models.order_model import Orders
import requests, os

order_controller = Blueprint("order_controller", __name__)
PRODUCTS_BASE_URL = os.getenv("PRODUCTS_BASE_URL") or "http://127.0.0.1:5003"

@order_controller.route('/api/orders', methods=['GET'])
def get_all_orders():
    rows = Orders.query.order_by(Orders.id.desc()).all()
    return jsonify([
        dict(id=o.id, userName=o.userName, userEmail=o.userEmail,
             saleTotal=float(o.saleTotal), date=o.date.isoformat())
        for o in rows
    ])

@order_controller.route('/api/orders/<int:order_id>', methods=['GET'])
def get_order(order_id):
    o = Orders.query.get_or_404(order_id)
    return jsonify(dict(
        id=o.id, userName=o.userName, userEmail=o.userEmail,
        saleTotal=float(o.saleTotal), date=o.date.isoformat()
    ))

@order_controller.route('/api/orders', methods=['POST'])
def create_order():
    data = request.get_json() or {}

    # Aceptar payload como {"user": {"name":..., "email":...}} aunque venga null,
    # y caer en valores por defecto si no hay datos.
    nested = data.get('user')
    if isinstance(nested, dict):
        if nested.get('name'):
            data.setdefault('userName', nested.get('name'))
        if nested.get('email'):
            data.setdefault('userEmail', nested.get('email'))

    # Usuario desde sesión o body, con defaults (para pruebas)
    user_name  = session.get('username') or data.get('userName')  or 'juan'
    user_email = session.get('email')    or data.get('userEmail') or 'juan@gmail.com'

    if not user_name or not user_email:
        return jsonify({'message': 'Información de usuario inválida'}), 400

    # (lo demás del endpoint queda igual)

    # Productos
    products = data.get('products')
    if not products or not isinstance(products, list):
        return jsonify({'message': 'Falta o es inválida la información de los productos'}), 400

    # Verificar stock y calcular total
    total = Decimal('0.00')
    final_items = []
    try:
        for item in products:
            pid = int(item['id'])
            qty = int(item['quantity'])
            r = requests.get(f"{PRODUCTS_BASE_URL}/api/products/{pid}", timeout=5)
            if r.status_code != 200:
                return jsonify({'message': f'Producto {pid} no encontrado'}), 404
            p = r.json()
            if p['quantity'] < qty:
                return jsonify({'message': f"Sin stock para {p['name']}", 'available': p['quantity']}), 409
            price = Decimal(str(p['price']))
            total += price * qty
            final_items.append((pid, qty))
    except (KeyError, ValueError, TypeError):
        return jsonify({'message': 'Formato de productos inválido'}), 400
    except requests.RequestException:
        return jsonify({'message': 'Productos no disponible'}), 503

    # Descontar inventario
    for pid, qty in final_items:
        try:
            adj = requests.post(f"{PRODUCTS_BASE_URL}/api/products/{pid}/adjust",
                                json={'delta': -qty}, timeout=5)
        except requests.RequestException:
            return jsonify({'message': f'Fallo al ajustar inventario de {pid}'}), 503
        if adj.status_code != 200:
            return jsonify({'message': 'No se pudo ajustar inventario', 'pid': pid}), 409

    # Guardar encabezado
    try:
        o = Orders(userName=user_name, userEmail=user_email, saleTotal=total)
        db.session.add(o); db.session.commit()
    except Exception as e:
        db.session.rollback()
        return jsonify({'message': 'Error al guardar la orden', 'error': str(e)}), 500

    return jsonify({'message': 'Orden creada exitosamente', 'order_id': o.id}), 201
